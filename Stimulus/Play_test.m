function [vblTimestamps, data] = Play_test( myScreenStim, myScreenInfo, mySyncSquare )% Plays visual stimuli and wave stimuli%% Play( myScreenStim, myScreenInfo ) plays object% myScreenStim of type ScreenStim on screen specified by myScreenInfo. %% Play( myScreenStim, myScreenInfo, mySyncSquare ) lets you specify Sync% Square parameters that may be different from those in myScreenInfo. %% [vblTimestamps, data ] = Play( ... ) returns the vblTimeStamps and the% data recorded by the DAQ. %% part of the Stimulus toolbox.% 2011-02 MC derived from oglStimPlay% 2011-04 MC disabled beeps because buggy and because they are a bad idea% 2013-02 MC added support for 64 bit data acquisition toolbox (but not yet for wave output)% 2013-07 DS added support for 64 bit wave outputdaqreset; % pretty radicalglobal AcquiredData % for use if we do DoWaves64if nargin < 3    mySyncSquare = [];endif nargin < 1    error('StimPlay:BadParameters', 'StimPlay needs at least one argument');end%%if isempty(myScreenStim)    fprintf('--------------- Empty stimulus ----------------\n');    returnendif myScreenStim.nFrames == 0 && isempty(myScreenStim.WaveStim)    fprintf('--------------- Empty stimulus ----------------\n');    returnend            if isempty(mySyncSquare)    mySyncSquare = myScreenInfo.SyncSquare;end%% The basic initializationsWinPtr = myScreenInfo.windowPtr;% this happens to work for single textures but not for multiple textures...if myScreenStim.MinusOneToOne    Screen('BlendFunction', myScreenInfo.windowPtr, GL_SRC_ALPHA, GL_ONE);else    Screen('BlendFunction', myScreenInfo.windowPtr, GL_ONE, GL_ZERO); % disables blending!end% Query duration of monitor refresh interval (for diagnostic)ifi = Screen('GetFlipInterval', WinPtr); %% Deal with the sync square% get the SyncRectSyncRect = mySyncSquare.GetSyncRect(myScreenInfo);sz = mySyncSquare.Size;BlackSync = Screen('MakeTexture', WinPtr, -ones(sz), 0, 0, 1);WhiteSync = Screen('MakeTexture', WinPtr,  ones(sz), 0, 0, 1); GraySync = Screen('MakeTexture', WinPtr, zeros(sz), 0, 0, 1);switch mySyncSquare.Type    case 'Steady'        FrameSyncs = [ WhiteSync; WhiteSync ];        PreAndPostSync = BlackSync;        DigValues  = [ true; true ];    case 'Flicker'        FrameSyncs = [ WhiteSync; BlackSync ];        PreAndPostSync = BlackSync;        DigValues  = [ true; false ];    case 'None'        BlackSync = GraySync;        FrameSyncs = [ GraySync; GraySync ];        PreAndPostSync = GraySync;        DigValues  = [ false; false ];    otherwise        error('Do not understand SyncSquare.Type');        end%% Sounds% BeepOn  = 0.5*MakeBeep(4400,0.1);% BeepOff = 0.5*MakeBeep(2200,0.1);Ringing = wavread('ringin.wav'); % cannot assume it is in 'C:\WINDOWS\Media'% oBeepOn  = audioplayer(BeepOn ,22000);% oBeepOff = audioplayer(BeepOff,22000);oRingRing = audioplayer([Ringing; Ringing], 2*8192);            %% Prepare the wave stimulationDoWaves = myScreenInfo.WaveInfo.DoWaves;fs = myScreenInfo.WaveInfo.SampleRate; % Hz switch computer        case 'PCWIN64'            DoWaves32 = false;            DoWaves64 = DoWaves;                otherwise                DoWaves32 = DoWaves;            DoWaves64 = false; end%hack for ZAP%DoWaves64 = DoWaves; if DoWaves32          ai = analoginput('nidaq',myScreenInfo.WaveInfo.DAQString) ;     ch = addchannel(ai,0:1); %#ok<NASGU> % adds two channels     ai.Channel.InputRange = [-10 10]; % apparently I can't do [0 10]          set(ai,'InputType','SingleEnded');     set(ai,'TriggerType','Manual');     set(ai,'SamplesPerTrigger',Inf);     set(ai,'SampleRate',fs);          do = digitalio('nidaq',myScreenInfo.WaveInfo.DAQString);     addline(do,0,'out');     putvalue(do,false);          if isfield(myScreenStim.WaveStim, 'Waves')         nChans = size(myScreenStim.WaveStim.Waves,2);     else         nChans = 0;     end     %sound or TTL output     switch nChans         case 0 % no wave outputs             ao = analogoutput('nidaq',myScreenInfo.WaveInfo.DAQString) ;             set(ao,'TriggerType','Manual');             addchannel(ao,0);             putdata(ao,zeros(100,1));         case 1 % sound             ao = analogoutput('winsound') ;             set(ao,'SampleRate',myScreenStim.WaveStim.SampleRate);             set(ao,'TriggerType','Manual');             addchannel(ao,[1 2]);             putdata(ao,[myScreenStim.WaveStim.Waves(:,1) myScreenStim.WaveStim.Waves(:,1)]);         case 2 % TTL 1ch             ao = analogoutput('nidaq',myScreenInfo.WaveInfo.DAQString);             set(ao,'SampleRate',myScreenStim.WaveStim.SampleRate);             set(ao,'TriggerType','Manual');             addchannel(ao,0); %AO0             putdata(ao,myScreenStim.WaveStim.Waves(:,2));         case 3 % TTL 1+2ch             ao = analogoutput('nidaq',myScreenInfo.WaveInfo.DAQString);             set(ao,'SampleRate',myScreenStim.WaveStim.SampleRate);             set(ao,'TriggerType','Manual');             addchannel(ao,[0 1]); %AO0 & AO1             putdata(ao,myScreenStim.WaveStim.Waves(:,2:3));     end                        start(do);     start(ai);     start(ao);          trigger(ai); % go! end  if DoWaves64               s = daq.createSession('ni');          s.addAnalogInputChannel(myScreenInfo.WaveInfo.DAQString,'ai0', 'Voltage');     s.addAnalogInputChannel(myScreenInfo.WaveInfo.DAQString,'ai1', 'Voltage');     s.Channels(1).InputType = 'Differential';     s.Channels(2).InputType = 'SingleEnded';     s.Rate = fs;     s.IsContinuous = true;     s.NotifyWhenDataAvailableExceeds = ceil(fs/10); % call it every 100 ms          AcquiredData.TimeStamps = zeros( fs*120, 1 );     AcquiredData.Data       = zeros( fs*120, 2);     AcquiredData.nSamples = 0;          s.addlistener('DataAvailable', @AddToData);          s1 = daq.createSession('ni'); % must be a different session!     s1.addDigitalChannel(myScreenInfo.WaveInfo.DAQString,'port0/line0','OutputOnly');     s1.outputSingleScan(0);          if ~isempty(myScreenStim.WaveStim)         error('Cannot yet output waveforms in Matlab 64 bit');         % will need to write code based on this legacy code:         % nChans = size(myScreenStim.WaveStim.Waves,2);         % addchannel(ao,0:(nChans-1));         % putdata(ao,myScreenStim.WaveStim.Waves);     end end %% Preallocate variables and load textures into VRAMPointerSequence = myScreenStim.GetPointerSequence;success = Screen('PreloadTextures', WinPtr, unique(PointerSequence));if ~success,    fprintf('WARNING: Failed to preload textures! Low video memory.\n');    play(oRingRing);end% get these out of the object so it is faster to access them:nFrames         = myScreenStim.nFrames;SourceRects     = myScreenStim.SourceRects;DestRects       = myScreenStim.DestRects;Orientations    = myScreenStim.Orientations;BilinearFiltering = myScreenStim.BilinearFiltering;Amplitudes      = myScreenStim.Amplitudes;if myScreenStim.BackgroundPersists    PersistColor = myScreenStim.BackgroundColor;else    PersistColor = GrayIndex(myScreenInfo.WhichScreen); % grayend%%  Go!% in case it is needed: put the black sync onScreen('DrawTexture', WinPtr, PreAndPostSync, [], SyncRect);Screen('Flip', WinPtr);% play(oBeepOn);Priority(2);Screen('FillRect',WinPtr,myScreenStim.BackgroundColor);   % fill the background color Screen('DrawTexture', WinPtr, PreAndPostSync, [], SyncRect);            vblTimestamps = zeros(nFrames+1, 1);		% record flip timesvblTimestamps(1) = Screen('Flip', WinPtr);if DoWaves32, trigger(ao); endif DoWaves64, s.startBackground; endfor iFrame = 1:nFrames    Screen('DrawTextures', ...        WinPtr, ...        PointerSequence(:,iFrame), ...        SourceRects(:,:,iFrame), ...        DestRects(:,:,iFrame), ...        Orientations(:,iFrame), ...        BilinearFiltering, ...        Amplitudes(:,iFrame));    % sync square (black or white, alternating)    Screen('DrawTexture', WinPtr, FrameSyncs(rem(iFrame+1,2)+1), [], SyncRect);    vblTimestamps(iFrame+1) = Screen('Flip', WinPtr);    if DoWaves32, putvalue(do,DigValues(rem(iFrame+1,2)+1)); end    if DoWaves64; s1.outputSingleScan(DigValues(rem(iFrame+1,2)+1)); endend% sync square offScreen('FillRect', WinPtr, PersistColor);Screen('DrawTexture', WinPtr, PreAndPostSync, [], SyncRect);Screen('Flip', WinPtr); % draw one last timeif DoWaves32, putvalue(do,false); endif DoWaves64; s1.outputSingleScan(0); endPriority(0);% play(oBeepOff); % WaitSecs(0.1); % so that the function does not exit too soon...%% Clear the offscreen windows that we made for the sync squares...Screen('Close', [BlackSync WhiteSync GraySync]);%% Calculate how much time it took to do all thisvblTimestamps = vblTimestamps - vblTimestamps(1);elapsed = vblTimestamps(end);PredDurBasedOnGlobalFrameRate = myScreenStim.nFrames / myScreenInfo.FrameRate;PredDurBasedOnLocalFrameRate  = myScreenStim.nFrames * ifi;fprintf('Duration: %3.3f s -- Predictions: %3.3f based on local FrameRate, %3.3f based on overall FrameRate\n', ...    elapsed, PredDurBasedOnLocalFrameRate, PredDurBasedOnGlobalFrameRate);if elapsed > PredDurBasedOnLocalFrameRate + ifi    fprintf('WARNING: should have been shorter by %3.1f ms\n',  1000*(elapsed-PredDurBasedOnGlobalFrameRate) );    beep; WaitSecs(1); %play(oRingRing); WaitSecs(1); % so that the function does not exit too soon...endif elapsed < PredDurBasedOnLocalFrameRate - ifi    fprintf('WARNING: should have been longer by %3.1f ms\n', -1000*(elapsed-PredDurBasedOnGlobalFrameRate) );    beep; WaitSecs(1); %play(oRingRing); WaitSecs(1); % so that the function does not exit too soon...enddts = diff(vblTimestamps);missedFrames = sum( dts > (1.05 * ifi) ); % was 1.20 up to 2007-10-03, 1.05 up to 2009-09-23 (all changes by MC)if missedFrames > 0,    fprintf('WARNING: Possible %d missed frames this repeat.\n', missedFrames);    beep; WaitSecs(1); %play(oRingRing); WaitSecs(1); % so that the function does not exit while ringing...end%% if DoWaves32    stop(ai);    stop(do);    stop(ao);    ns = get(ai,'SamplesAvailable');    data = getdata(ai,ns);   %     %% plot the data%     %     tt = (1:ns)/fs;%     %     figure;%     plot(tt,data);%     xlabel('Time (s)')%     ylabel('Signal (Volts)');%     set(gca,'xlim',[0 Inf],'ylim',[0 Inf]);    endif DoWaves64    s.stop;    if AcquiredData.nSamples ~= s.ScansAcquired        fprintf('Acquired %d samples instead of %d\n',s.ScansAcquired,AcquiredData.nSamples);    end        ii = 1:AcquiredData.nSamples;    data = AcquiredData.Data(ii,:);    end