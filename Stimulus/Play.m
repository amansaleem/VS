function [vblTimestamps, data] = Play( myScreenStim, myScreenInfo, mySyncSquare )% Plays visual stimuli and wave stimuli%% Play( myScreenStim, myScreenInfo ) plays object% myScreenStim of type ScreenStim on screen specified by myScreenInfo.%% Play( myScreenStim, myScreenInfo, mySyncSquare ) lets you specify Sync% Square parameters that may be different from those in myScreenInfo.%% [vblTimestamps, data ] = Play( ... ) returns the vblTimeStamps and the% data recorded by the DAQ.%% part of the Stimulus toolbox.% 2011-02 MC derived from oglStimPlay% 2011-04 MC disabled beeps because buggy and because they are a bad idea% 2013-02 MC added support for 64 bit data acquisition toolbox (but not yet for wave output)% 2013-07 DS added support for 64 bit wave output (startBackground takes some time..)% 2013-10 MK added support for 'HwDigital' ao triggertype (32-bit interface)%            it allows synchronizing the wave with the sync square% 2014-04 MO fixing AO termination issue (in 32bit only)% 2014-05 MO fixing how frame timing is countedStartTime = tic;daqreset; % pretty radicalglobal AcquiredData % for use if we do DoWaves64if nargin < 3    mySyncSquare = [];endif nargin < 1    error('StimPlay:BadParameters', 'StimPlay needs at least one argument');end%%if isempty(myScreenStim)    fprintf('--------------- Empty stimulus ----------------\n');    returnendif myScreenStim.nFrames == 0 && isempty(myScreenStim.WaveStim)    fprintf('--------------- Empty stimulus ----------------\n');    returnendif isempty(mySyncSquare)    mySyncSquare = myScreenInfo.SyncSquare;end%% The basic initializationsWinPtr = myScreenInfo.windowPtr;% this happens to work for single textures but not for multiple textures...if myScreenStim.MinusOneToOne    Screen('BlendFunction', myScreenInfo.windowPtr, GL_SRC_ALPHA, GL_ONE);else    Screen('BlendFunction', myScreenInfo.windowPtr, GL_ONE, GL_ZERO); % disables blending!end% Query duration of monitor refresh interval (for diagnostic)ifi = Screen('GetFlipInterval', WinPtr);%% Deal with the sync square% get the SyncRectSyncRect = mySyncSquare.GetSyncRect(myScreenInfo);sz = mySyncSquare.Size;BlackSync = Screen('MakeTexture', WinPtr, -ones(sz), 0, 0, 1);WhiteSync = Screen('MakeTexture', WinPtr,  ones(sz), 0, 0, 1);GraySync = Screen('MakeTexture', WinPtr, zeros(sz), 0, 0, 1);switch mySyncSquare.Type    case 'Steady'        FrameSyncs = [ WhiteSync; WhiteSync ];        PreAndPostSync = BlackSync;        DigValues  = [ true; true ];    case 'Flicker'        FrameSyncs = [ WhiteSync; BlackSync ];        PreAndPostSync = BlackSync;        DigValues  = [ true; false ];    case 'Flicker-Steady'%DS on 13.11.1. digital output remains steady while sync square flickers         FrameSyncs = [ WhiteSync; BlackSync ];        PreAndPostSync = BlackSync;        DigValues  = [ true; true ];    case 'flickergrey'        FrameSyncs = [ WhiteSync; BlackSync ];        PreAndPostSync = GraySync;        DigValues  = [ true; false ];    case 'None'        BlackSync = GraySync;        FrameSyncs = [ GraySync; GraySync ];        PreAndPostSync = GraySync;        DigValues  = [ false; false ];    otherwise        error('Do not understand SyncSquare.Type');end%% Sounds% BeepOn  = 0.5*MakeBeep(4400,0.1);% BeepOff = 0.5*MakeBeep(2200,0.1);Ringing = wavread('ringin.wav'); % cannot assume it is in 'C:\WINDOWS\Media'% oBeepOn  = audioplayer(BeepOn ,22000);% oBeepOff = audioplayer(BeepOff,22000);oRingRing = audioplayer([Ringing; Ringing], 2*8192);%% Prepare the wave stimulationDoWaves = myScreenInfo.WaveInfo.DoWaves;fs = myScreenInfo.WaveInfo.SampleRate; % Hzfs = 125e3; % 10.20.13      % who edited this? and why????switch computer    case 'PCWIN64'        DoWaves32 = false;        DoWaves64 = DoWaves;            otherwise        DoWaves32 = DoWaves;        DoWaves64 = false;end%test for ZAP% DoWaves32 = false;% DoWaves64 = DoWaves;if DoWaves32        ai = analoginput('nidaq',myScreenInfo.WaveInfo.DAQString) ;    ch = addchannel(ai,0:1); %#ok<NASGU> % adds two channels    ai.Channel.InputRange = [-10 10]; % apparently I can't do [0 10]        set(ai,'InputType','SingleEnded');    set(ai,'TriggerType','Manual');    set(ai,'SamplesPerTrigger',Inf);    set(ai,'SampleRate',fs);        do = digitalio('nidaq',myScreenInfo.WaveInfo.DAQString);    addline(do,0,'out');    putvalue(do,false);        ao = analogoutput('nidaq',myScreenInfo.WaveInfo.DAQString) ;        % The following lines were added by Krumin to trigger the analog output    % by the sync square on the screen.     AOTriggerType='Manual'; %default option    if isfield(myScreenStim.WaveStim, 'TriggerType') %then override the default      AOTriggerType=myScreenStim.WaveStim.TriggerType;    end    set(ao,'TriggerType',AOTriggerType);    if isequal(AOTriggerType, 'HwDigital')      set(ao, 'TriggerCondition', 'PositiveEdge'); % will trigger on rising edge      set(ao, 'HwDigitalTriggerSource', 'PFI0'); % otherwise by default will be PFI6    end    % ------------------- end lines added by Krumin        if ~isempty(myScreenStim.WaveStim)        set(ao,'SampleRate',myScreenStim.WaveStim.SampleRate);        nChans = size(myScreenStim.WaveStim.Waves,2);        addchannel(ao,0:(nChans-1));        putdata(ao,myScreenStim.WaveStim.Waves);    else        addchannel(ao,0);        putdata(ao,zeros(100,1));    end        start(do);    start(ai);    start(ao);        trigger(ai); % go!endif DoWaves64        s = daq.createSession('ni');        s.addAnalogInputChannel(myScreenInfo.WaveInfo.DAQString,'ai0', 'Voltage');    s.addAnalogInputChannel(myScreenInfo.WaveInfo.DAQString,'ai1', 'Voltage');    s.Channels(1).InputType = 'Differential';    s.Channels(2).InputType = 'SingleEnded';    s.Rate = fs;    s.IsContinuous = true;    s.NotifyWhenDataAvailableExceeds = ceil(fs/10); % call it every 100 ms            AcquiredData.TimeStamps = zeros( fs*120, 1 );    AcquiredData.Data       = zeros( fs*120, 2);    AcquiredData.nSamples = 0;        s.addlistener('DataAvailable', @AddToData);        s1 = daq.createSession('ni'); % must be a different session!%     if ~isfield(myScreenInfo.WaveInfo,'FrameSyncChannel')        s1.addDigitalChannel(myScreenInfo.WaveInfo.DAQString,'port0/line0','OutputOnly');%     end    s1.outputSingleScan(0);       %analog output    s2 = daq.createSession('ni');        if ~isempty(myScreenStim.WaveStim)        nChans = size(myScreenStim.WaveStim.Waves,2);        s2.addAnalogOutputChannel(myScreenInfo.WaveInfo.DAQString, 0:(nChans-1), 'Voltage');        s2.Rate = myScreenStim.WaveStim.SampleRate;        s2.queueOutputData(myScreenStim.WaveStim.Waves);    else        s2.addAnalogOutputChannel(myScreenInfo.WaveInfo.DAQString, 0, 'Voltage');        s2.queueOutputData(zeros(100,1));    end        % still to do: add the equivalent of the lines that Krumin added to the    % 32-bit case to trigger acquisition on PFI0.end%% Preallocate variables and load textures into VRAMPointerSequence = myScreenStim.GetPointerSequence;success = Screen('PreloadTextures', WinPtr, unique(PointerSequence));if ~success,    fprintf('WARNING: Failed to preload textures! Low video memory.\n');    play(oRingRing);end% get these out of the object so it is faster to access them:nFrames         = myScreenStim.nFrames;SourceRects     = myScreenStim.SourceRects;DestRects       = myScreenStim.DestRects;Orientations    = myScreenStim.Orientations;BilinearFiltering = myScreenStim.BilinearFiltering;Amplitudes      = myScreenStim.Amplitudes;if myScreenStim.BackgroundPersists    PersistColor = myScreenStim.BackgroundColor;else    PersistColor = GrayIndex(myScreenInfo.WhichScreen); % grayendif DoWaves64,    s.prepare;    s2.prepare;end%%  Go!Duration = toc(StartTime);fprintf('Playing stimulus (after %2.2f s of overhead)\n',Duration);% in case it is needed: put the black sync onScreen('DrawTexture', WinPtr, PreAndPostSync, [], SyncRect);Screen('Flip', WinPtr);% play(oBeepOn);vblTimestamps = zeros(nFrames+1, 1);		% record flip timesPriority(2);Screen('FillRect',WinPtr,myScreenStim.BackgroundColor);   % fill the background colorScreen('DrawTexture', WinPtr, PreAndPostSync, [], SyncRect);if DoWaves32  if isequal(AOTriggerType, 'Manual')    trigger(ao);   else    %do nothing, it is either 'HwDigital' and will start automatically or     %it is 'Immediate' and has already started together with start(ao)  endendif DoWaves64 %takes ~80ms in ZAP. outputSingleScan does not change the timing    s.startBackground;    s2.startBackground;    %    s2.outputSingleScan(0:(nChans-1));endvblTimestamps(1) = Screen('Flip', WinPtr);for iFrame = 1:nFrames    Screen('DrawTextures', ...        WinPtr, ...        PointerSequence(:,iFrame), ...        SourceRects(:,:,iFrame), ...        DestRects(:,:,iFrame), ...        Orientations(:,iFrame), ...        BilinearFiltering, ...        Amplitudes(:,iFrame));    % sync square (black or white, alternating)    Screen('DrawTexture', WinPtr, FrameSyncs(rem(iFrame+1,2)+1), [], SyncRect);    % commment by Matteo: SNAPSHOT=Screen('GetImage', WinPtr, [], [], 0, 1);    vblTimestamps(iFrame+1) = Screen('Flip', WinPtr);    if DoWaves32, putvalue(do,DigValues(rem(iFrame+1,2)+1)); end    if DoWaves64; s1.outputSingleScan(DigValues(rem(iFrame+1,2)+1)); endend% sync square offScreen('FillRect', WinPtr, PersistColor);Screen('DrawTexture', WinPtr, PreAndPostSync, [], SyncRect);Screen('Flip', WinPtr); % draw one last timeif DoWaves32, putvalue(do,false); endif DoWaves64; s1.outputSingleScan(0); endPriority(0);% play(oBeepOff);% WaitSecs(0.1); % so that the function does not exit too soon...%% Clear the offscreen windows that we made for the sync squares...Screen('Close', [BlackSync WhiteSync GraySync]);%% Calculate how much time it took to do all thisvblTimestamps = vblTimestamps - vblTimestamps(1);elapsed = vblTimestamps(end);PredDurBasedOnGlobalFrameRate = myScreenStim.nFrames / myScreenInfo.FrameRate;PredDurBasedOnLocalFrameRate  = myScreenStim.nFrames * ifi;fprintf('Duration: %3.3f s -- Predictions: %3.3f based on local FrameRate, %3.3f based on overall FrameRate\n', ...    elapsed, PredDurBasedOnLocalFrameRate, PredDurBasedOnGlobalFrameRate);if elapsed > PredDurBasedOnLocalFrameRate + ifi    fprintf('WARNING: should have been shorter by %3.1f ms\n',  1000*(elapsed-PredDurBasedOnGlobalFrameRate) );    %beep; WaitSecs(0.1); %play(oRingRing); WaitSecs(1); % so that the function does not exit too soon...endif elapsed < PredDurBasedOnLocalFrameRate - ifi    fprintf('WARNING: should have been longer by %3.1f ms\n', -1000*(elapsed-PredDurBasedOnGlobalFrameRate) );    %beep; WaitSecs(0.1); %play(oRingRing); WaitSecs(1); % so that the function does not exit too soon...enddts = diff(vblTimestamps);missedFrames = sum( dts > (1.05 * ifi) ); % was 1.20 up to 2007-10-03, 1.05 up to 2009-09-23 (all changes by MC)if missedFrames > 0,    fprintf('WARNING: Possible %d missed frames this repeat.\n', missedFrames);    %beep; WaitSecs(0.1); %play(oRingRing); WaitSecs(1); % so that the function does not exit while ringing...end%%if DoWaves32    wait(ao, 30); % mush, 28/4/14: Wait (for 30s) for AO to finish rather than abruptly terminating it.    stop(ai);    stop(do);    %stop(ao);        ns = get(ai,'SamplesAvailable');    data = getdata(ai,ns);        %     %% plot the data    %    %     tt = (1:ns)/fs;    %    %     figure;    %     plot(tt,data);    %     xlabel('Time (s)')    %     ylabel('Signal (Volts)');    %     set(gca,'xlim',[0 Inf],'ylim',[0 Inf]);    endif DoWaves64    s.stop;    s2.stop;    if AcquiredData.nSamples ~= s.ScansAcquired        fprintf('Acquired %d samples instead of %d\n',s.ScansAcquired,AcquiredData.nSamples);    end        ii = 1:AcquiredData.nSamples;    data = AcquiredData.Data(ii,:);endDuration = toc(StartTime);fprintf('... done (after %2.2f in total)\n',Duration);